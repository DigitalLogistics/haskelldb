:set -fprint-evld-with-show
:set stop :list
:set -i..\src -i..\driver-hdbc -i..\driver-hdbc-postgresql

let sl _ = return ":steplocal"
:def sl sl

let s _ = return ":step"
:def s s

let sm _ = return ":stepmodule"
:def sm sm

-- Run one of the query tests in TestCases. Just give
-- the name of the function.
let xqt test = return $ "Test.HUnit.Text.runTestTT (" ++ test ++ " undefined undefined)"
:def xqt xqt

-- Print SQL for a query
let pSQL query = return $ "Database.HaskellDB.PrintQuery.ppSql " ++ query
:def pSQL pSQL

-- Print SQL for a query
let pSQLU query = return $ "Database.HaskellDB.PrintQuery.ppSqlUnOpt " ++ query
:def pSQLU pSQLU

-- Print intermediate SqlSelect, after optimization, for a query.
let pSelect query = return $ "Database.HaskellDB.PrintQuery.ppSelect " ++ query
:def pSelect pSelect

-- Print intermediate SqlSelect, unoptimized, for a query.
let pSelectU query = return $ "Database.HaskellDB.PrintQuery.ppSelectUnOpt " ++ query
:def pSelectU pSelectU

-- Print the PrimQuery data structure for a query, after optimization.
let pQuery query = return $ "Database.HaskellDB.PrintQuery.ppQuery " ++ query
:def pQuery pQuery

-- Print the PrimQuery data structure for a query, no optimization.
let pQueryU query = return $ "Database.HaskellDB.PrintQuery.ppQueryUnOpt " ++ query
:def pQueryU pQueryU

:add Database.HaskellDB.PrintQuery
:add *TestCases
:m *TestCases 

:{
let goodOpt = do {
        v <- subQuery $ do {
          h <- table int_tbl;
          project $ TInt.f02 << _case [((h ! TInt.f02) .==. constant 100, constant 0)] (constant (1::Int)) 
                      # TInt.f04 << count (h ! TInt.f01); };
        unique;
        project $ copyAll v; }
:}

:{
let badOpt = do {
        v <- subQuery $ do {
              t1 <- table int_tbl;
              unique;
              project $ TInt.f02 << (t1 ! TInt.f02); };
        project $ TInt.f02 << count(v ! TInt.f02); }
:}
