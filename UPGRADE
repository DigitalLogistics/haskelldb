Instructions for upgrading from haskelldb-0.12 to 1.0

### GHC Only

HaskellDB can only be compiled by GHC, due to its use of
HList-required extensions.

### Breaking Changes

HaskellDB 1.0 breaks backward compatability with 0.13 in order to
provided integration with the HList library. The following gives all
the areas where compatability has been broken and how to fix it.

## Operators

The following HaskellDB operators have been replaced:

  * ''!'' becomes ''.!.''
  * ''<<'' becomes ''.=.''
  * ''#'' becomes ''.*.''
  * Additionally, the construction ''field <<- value'' becomes ''field .=. constant value''

## ''project'' changes

The ''project'' function takes a list of records as before, but that
list must be terminated by ''emptyRecord''. For example,

  project $ TInt.f02 << t ! TInt.f02

becomes 

  project $ TInt.f02 .=. s .!. TInt.f02 .*. emptyRecord

## ''baseTable''

baseTable loses an argument - it only needs the table name and the inferred type. E.g.,

  my_table :: Table My_table
  my_table = baseTable "my_table" $
             hdbMakeEntry My_table_id # ...

becomes

  my_table :: Table My_table
  my_table = baseTable "my_table"

## Module Exports

The following gives functions which are no longer exported, by module:

  * Database.HaskellDB
    * ''Attr'' - no replacement necessary. Delete any types associated
    with this declaration. That is:

      ''my_field :: Attr My_field Int''

    becomes

      ''my_field :: My_field''
    * ''(<<)'' - replace with ''(.=.)''.
    * ''(!)'' - replace with ''(.!.)''
  * Database.HaskellDB.Query
    * ''attributeName'' - replace with ''showLabel'', exported by
    Database.HaskellDB.
  * Database.HaskellDB.DBLayout
    * ''mkAttr'' - replace with ''proxy'', exported by this
    module. E.g.:

      data Foo = Foo
      foo :: Attr Foo (Maybe Int)
      foo = mkAttr Foo

    becomes

      data Foo
      foo :: Foo
      foo = proxy
    * ''hdbMakeEntry'' - no replacement necessary. E.g.:

      my_table :: Table My_table
      my_table = baseTable "my_table" $
                 hdbMakeEntry Foo # ...

    becomes

      my_table :: Table My_table
      my_table = baseTable "my_table"

    However, ''hdbMakeEntry'' could also be used to construct default
    values in a table. This construction is replaced by
    projection. See below under ''row construction'' for more
    information.
    * fieldName - replace with ''showLabel''.
  * Database.HaskellDB.HDBRec - this module has been
  removed. Replacements for exports are given below.
    * ''HasField'' - now imported from HList, and exported from
    ''Database.HaskellDB''.
    * ''ShowRecRow'' - ''Record'' is an instance of ''Show'', as long as each
    value can be shown.
    * ''ShowLabels'' - becomes ''RecordLabels'', from HList and exported
    by ''Database.HaskellDB''.
    * ''recordLabels'' - replace with ''recordLabels'', from HList and
    exported by ''Database.HaskellDB''.
    * ''RecCons'' - becomes ''HCons'' from HList and exported by
    ''Database.HaskellDB''.
    * ''RecNil'' - becomes ''HNil''  from HList and exported by
    ''Database.HaskellDB''.
    * ''Record'' - reuses ''Record'' from HList and exported by
    ''Database.HaskellDB''.
    * ''(#)'' -  becomes ''(.*.)'', from HList and exported  by
    ''Database.HaskellDB''.
    * FieldTag - replaced with ShowLabel, from HList and exported by
    ''Database.HaskellDB''.

## ''Query'' type changes

Any occurence of ''Query (Rel r)'' in a signature should become ''Query
(Rel (Record r))''.

### DBDirect changes

DBDirect has been updated to compatible code, so when possible the
definitions should be regenerated. The list of changes below can be
used when that is not feasible.

Pragma additions:

  {-# LANGUAGE EmptyDataDecls, TypeSynonymInstances #-}

must be added to the top of each file, or the equivalent GHC arguments
must be used.

Import changes:

  import Database.HaskellDB.HDBRec (Record, (!))
  import Database.HaskellDB.Query ((<<), Rel)

Is no longer required at the top of DBDirect generated files.

Table types:

  type My_table = (RecCons Foo (Expr (Maybe Int))
                   (RecCons ... (Expr ...) (... RecNil)))

becomes

   type My_table = Record (HCons (LVPair Foo
                                         (Expr (Maybe Int)))
                          (HCons (..) (... HNil)))

''RecCons'' and ''RecNil'' are no longer and are replaced with
''HCons'' and ''HNil'', respectively. Each field is defined by an
''LVPair'' declaration.

Table declaration:

   my_table :: Table My_table
   my_table = baseTable "my_table" $
              hdbMakeEntry Foo # ...

becomes

   my_table :: Table My_table
   my_table = baseTable "my_table"

''baseTable'' only takes one argument, the name of the underlying
table. ''hdbMakeEntry'' is no longer required. 

Field declarations:

   data Foo = Foo

   instance FieldTag Foo where
       fieldName _ = "foo"

   foo :: Attr Foo (Maybe Int)
   foo = mkAttr Foo

becomes

   data FooTag
   type Foo = Proxy fooTag
   instance ShowLabel Foo where
       showLabel _ = "foo"

   foo :: Foo
   foo = proxy

Empty constructors are now used, ''FieldTag'' has been replaced with
''ShowLabel'' and ''Attr'' is no longer needed. Note also that the
data type has a ''Tag'' suffix, while the type synonym does not.

### Import changes

The below import is sometimes required. If you see error messages
regarding "HRLabelSet'", "TypeEq" or other oddities, try adding it:

  import Data.HList.TypeCastGeneric1 ()

### Constructing Rows

Sometimes a query needs to manufacture rows. For example, you might
want a query such as:

  SELECT 1 as foo,
         'a' as bar,
  FROM information_schema.information_schema_catalog_name as T1
  UNION ALL
  SELECT 3 as foo,
         'b' as bar,
  FROM information_schema.information_schema_catalog_name as T1

You first have to define the table type in code, use the 'table'
operator (even if you don't use the result) and then define an individual row:

  fakeRows = do
    let tbl :: Table (Record (HCons (LVPair Foo (Expr Int))
                               (HCons (LVPair Bar (Expr String)) HNil)))
        tbl = baseTable "information_schema.information_schema_catalog_name" 
        fakeRow int str = do
          _ <- table tbl
          project $ foo .=. constant int
                    .*. bar .=. constant str
                    .*. emptyRecord
    fakeRow 1 "a" `union`
      fakeRow 3 "b" 


