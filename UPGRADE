Instructions for upgrading from haskelldb-0.12 to 1.0

** HList changes **

The changes below show what changed in a DBDirect generated module
with the HList implementation

*
  import Database.HaskellDB.HDBRec (Record, (!))
  import Database.HaskellDB.Query ((<<), Rel)

No longer required at the top of DBDirect generated files.

*
  RecCons Pts_dlvry_order_hdr_id (Expr (Maybe Int))

becomes

  HCons Pts_dlvry_order_hdr_id (Expr (Maybe Int))

*
  type Pts_dlvry_carryover_v = (RecCons (...))

becomes

   type Pts_dlvry_carryover_v = Record ( ... )


*
   pts_dlvry_carryover_v :: Table Pts_dlvry_carryover_v

   pts_dlvry_carryover_v = baseTable "pts_dlvry_carryover_v" $
                           hdbMakeEntry Pts_dlvry_order_hdr_id #
                           ...

becomes

   pts_dlvry_carryover_v :: Table Pts_dlvry_carryover_v
   pts_dlvry_carryover_v = baseTable "pts_dlvry_carryover_v"

*
   data Pts_dlvry_order_hdr_id = Pts_dlvry_order_hdr_id

   instance FieldTag Pts_dlvry_order_hdr_id where
       fieldName _ = "pts_dlvry_order_hdr_id"

   pts_dlvry_order_hdr_id :: Attr Pts_dlvry_order_hdr_id (Maybe Int)
   pts_dlvry_order_hdr_id = mkAttr Pts_dlvry_order_hdr_id

becomes

   data Pts_dlvry_order_hdr_idTag
   type Pts_dlvry_order_hdr_id = Proxy Pts_dlvry_order_hdr_idTag
   instance ShowLabel Pts_dlvry_order_hdr_id where
       showLabel _ = "pts_dlvry_order_hdr_id"

   pts_dlvry_order_hdr_id :: Pts_dlvry_order_hdr_id
   pts_dlvry_order_hdr_id = proxy

Note also that "data" type has "Tag" suffix, while type synonym does not.
   
*
   ---------------------------------------------------------------------------
   -- All fields as a Record for projection
   ---------------------------------------------------------------------------
   record :: Rel Pts_dlvry_carryover_v -> Record Pts_dlvry_carryover_v
   record tbl =  pts_dlvry_order_hdr_id << tbl ! pts_dlvry_order_hdr_id #


is missing ...

*

   Module `Database.HaskellDB' does not export `Attr'
   Module `Database.HaskellDB' does not export `(<<)'
   Module `Database.HaskellDB' does not export `(!)'
   Module `Database.HaskellDB.DBLayout' does not export `mkAttr'
   Module `Database.HaskellDB.DBLayout' does not export `hdbMakeEntry'
   Module `Database.HaskellDB.DBLayout' does not export `fieldName'

* 

Add these pragmas to generated files

  {-# LANGUAGE EmptyDataDecls, TypeSynonymInstances #-}

Or these GHC arguments

  -XEmptyDataDecls -XTypeSynonymInstances

* 

Operators which have changed:

  (!) becomes (.!.)
  (<<) becomes (.=.)
  (#) becomes (.*.)
  (field <<- value) becomes (field .=. constant value)

  project $ TInt.f02 << count(s ! TInt.f02)

becomes 

  project $ TInt.f02 .=. count(s .!. TInt.f02) .*. emptyRecord

* 

Database.HaskellDB.HDBRec goes away. Equivalents:

  HasField is imported from HList.

  ShowRecRow can be removed.

  ShowLabels becomes ShowLabel (from Database.HaskellDB)

  recordLabels is imported from HList (as is recordValues).

  RecCons(..) becomes HCons.

  Record is imported from HList

  RecNil becomes HNil.

  (#) becomes (.*.)

  FieldTag is removed.

* 

Instances of (Query (Rel r)) should become (Query (Rel (Record r))) - double check this.

* 

RecordValues and RecordLabels classes need to be added to contexts in what situation?

* 
  Module `Database.HaskellDB' does not export `Attr'

replace with nothing - no longer needed. Use the type-level field name instead.

  Module `Database.HaskellDB' does not export `(<<)'

replace with (.=.)

  Module `Database.HaskellDB' does not export `(!)'

replace with (.!.)

  Module `Database.HaskellDB.Query' does not export `attributeName'

replace with ?

  Module `Database.HaskellDB.DBLayout' does not export `mkAttr'

replace with ?

  Module `Database.HaskellDB.DBLayout' does not export `hdbMakeEntry'

replace with nothing - not needed. Previously used to create values in a record
for baseTable. Now baseTable does not create any values. Values are created 
through projection if needed.

  Module `Database.HaskellDB.DBLayout' does not export `fieldName'

replace with ?

* 

Use of queryFields from Database.HaskellDB.FieldType requires you to
have type signatures like

     (ExprTypes r     
     , ShowLabel r
     , RecordLabels r ls
     , RecordValues r vs
     , HMapOut ShowLabelsOp ls String
     , HMapOut FromHaskellTypesOp vs FieldDesc) => Query (Rel (Record r)) ... ?

ShowLabelsOp must be imported from Database.HaskellDB.Query. FromHaskellTypesOp must
be imported from Database.HaskellDB.FieldType.

Can type aliases be created to make these easier on the eyes?

*

baseTable loses an argument - it only needs the table name and the inferred type. E.g.,

  pts_dlvry_carrier :: Table Pts_dlvry_carrier
  pts_dlvry_carrier = baseTable "pts_dlvry_carrier" $
                      hdbMakeEntry Pts_dlvry_carrier_id #
                      hdbMakeEntry Bus_unit_id #
                      hdbMakeEntry Carrier_desc_txt #
                      hdbMakeEntry Create_user_id #
                      hdbMakeEntry Create_dt #
                      hdbMakeEntry Mod_user_id #
                      hdbMakeEntry Mod_dt

becomes

  pts_dlvry_carrier :: Table Pts_dlvry_carrier
  pts_dlvry_carrier = baseTable "pts_dlvry_carrier"

* 

Fixity of .!. does not match fixity of (!). What about (.*.) and (.=.)? This means most 
queries which use .!. need parentheses, since .=. has higher fixity. Makes it worthwhile
to maintain old ! operator?

*

Below import *sometimes* required. Otherwise, get weird errors: HasField', column type past first
element in Record will not be determined.

  import Data.HList.TypeCastGeneric1 ()


Probably HList should export this, but HaskellDB ought to otherwise.

 *

emptyRecord must be added at the end of any project which only has a single
field. Otherwise, it can be omitted.

* 

Building a table with rows in code is impossible without a small fix
to removeEmpty in Optimize.hs. 

That is, queries like 

  SELECT 0 as pts_dm_event_dtl_id,
         0 as pts_dm_event_hdr_id,
         0 as pts_dlvry_order_dtl_id,
         0 as pts_dlvry_order_hdr_id,
         '' as cora_dtl_item_id,
         0 as event_nbr
  FROM information_schema.information_schema_catalog_name as T1

and

  SELECT 'I' as src_doc_type_cd,
          ? as src_doc_type_cd_txt
   FROM information_schema.information_schema_catalog_name as T1

are very hard.

To build a table now, you have to define the table type in code, use the 'table'
operator (even if you don't use the result) and then define an individual row:

  pts_dlvry_src_doc_type_cd = do
    let tbl :: Table (Record (HCons (LVPair Src_doc_type_cd (Expr String))
                               (HCons (LVPair Src_doc_type_cd_txt (Expr String)) HNil)))
        tbl = baseTable "information_schema.information_schema_catalog_name" 
        src_doc_type_cd_row code text_param = do
          _ <- table tbl
          project $ src_doc_type_cd .=. constant code 
                    .*. src_doc_type_cd_txt .=. namedParam text_param (constant "")
                    .*. emptyRecord
    src_doc_type_cd_row "I" "invoice_txt" `union`
      src_doc_type_cd_row "RO" "ro_txt"

Without the fix, the first works (defining the type) but the second does not (adding rows). You get 
queries like:

  SELECT pts_dm_event_hdr_id,
         pts_dlvry_order_hdr_id,
         bus_unit_id,
         src_doc_type_cd,
         src_doc_open_yr_mo,
         src_doc_id,
         src_doc_bus_unit_id,
         event_nbr
  FROM information_schema.information_schema_catalog_name as T1

with no default values, and:

  SELECT 'I' as src_doc_type_cd,
          ? as src_doc_type_cd_txt

where the table to select from has been lost. The removeEmpty
optimization in Optimize.hs was too aggressive. When a projection had
no columns, it was replaced with Empty. Constant queries against a
table with all fake columns would be generated incorrectly in that
case. Easy fix in removeEmpty.

A unit test for this situation has been added (testFakeSelect).