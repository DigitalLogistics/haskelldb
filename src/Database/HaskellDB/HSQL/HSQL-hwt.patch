Index: Makefile
===================================================================
RCS file: /cvsroot/htoolkit/HSQL/Makefile,v
retrieving revision 1.5
diff -u -u -r1.5 Makefile
--- Makefile	7 Sep 2003 22:56:18 -0000	1.5
+++ Makefile	4 Jan 2004 03:14:13 -0000
@@ -14,6 +14,15 @@
 
 OBJS    = $(patsubst %.hs,%.o, $(HS_SRC))
 HI_SRC  = $(patsubst %.hs,%.hi,$(HS_SRC))
+SO_SRC  = $(patsubst %.hs,%.so,$(HS_SRC))
+
+COMPILERS = ghc
+ifeq "$(WithHUGS)" "YES"
+COMPILERS += hugs
+endif
+
+HUGS_C_FLAGS = $(patsubst %, +L"%", $(CPPFLAGS)) 
+HUGS_C_FLAGS += $(patsubst %, +L"%", $(LDFLAGS))
 
 ifeq "$(HADDOCK)" ""
 HADDOCK = echo
@@ -31,7 +40,14 @@
 %.raw-hs : %.hs
 	$(GHC) -Iincludes $(CPPFLAGS) -D__HADDOCK__ -E -cpp $< -o $<.tmp && sed -e 's/^#.*//' <$<.tmp >$@
 
-all: libHSsql.a
+%.so: %.hs
+	$(FFIHUGS) -98 +G $(HUGS_C_FLAGS) $<
+
+all: $(patsubst %, all-%, $(COMPILERS))
+
+all-ghc: libHSsql.a
+
+all-hugs: $(SO_SRC)
 
 libHSsql.a: $(OBJS)
 	rm -f libHSsql.a
@@ -42,16 +58,29 @@
 depend: $(HS_SRC)
 	$(GHC) -M $^
 	
+genclean: distclean
+	rm -rf configure autom4te.cache
+
+distclean: clean
+	rm -f libHSsql.a
+	rm -f config.status config.log config.mk hsql.pkg
+
 clean:
 	rm -f $(OBJS)
 	rm -f $(HI_SRC)
+	rm -f $(SO_SRC)
+	rm -f $(HS_SRC)
+	rm -f $(patsubst %.hs,%.c,$(HS_SRC))
 	rm -f $(HS_PPS)
+	rm -rf $(patsubst %.o,%_split, $(OBJS))
 	
 docs : $(HS_PPS)
 	mkdir -p doc
 	$(HADDOCK) -h -o doc $(HS_PPS)
 
-install: libHSsql.a $(HI_SRC) docs
+install: $(patsubst %, install-%, $(COMPILERS))
+
+install-ghc: libHSsql.a $(HI_SRC) docs
 	$(INSTALL) libHSsql.a $(prefix)/libHSsql.a
 	$(INSTALL) -d $(prefix)/imports/Database
 	for i in $(HI_SRC); do \
@@ -64,5 +93,12 @@
 	   $(INSTALL) -d $(prefix)/doc/html/hsql; \
 	   $(INSTALL) -c doc/* $(prefix)/doc/html/hsql; \
 	fi
+
+install-hugs: $(HS_SRC) $(SO_SRC)
+	$(INSTALL) -d $(HUGS_DIR)/libraries/Database
+	for i in $(HS_SRC) $(SO_SRC); do \
+	   $(INSTALL) -d $(HUGS_DIR)/libraries/Database/`dirname $$i`; \
+	   $(INSTALL) -c $$i $(HUGS_DIR)/libraries/Database/`dirname $$i`; \
+	done
 
 ODBC/HSQL.hs : ODBC/HSQLStructs.h
Index: config.mk.in
===================================================================
RCS file: /cvsroot/htoolkit/HSQL/config.mk.in,v
retrieving revision 1.1
diff -u -u -r1.1 config.mk.in
--- config.mk.in	5 Sep 2003 11:37:55 -0000	1.1
+++ config.mk.in	4 Jan 2004 03:14:13 -0000
@@ -12,3 +12,8 @@
 exec_prefix = @exec_prefix@
 CPPFLAGS = @CPPFLAGS@
 HADDOCK = @HADDOCK@
+
+WithHUGS = @WithHUGS@
+HUGS_DIR = @HUGS_DIR@
+FFIHUGS = @FFIHUGS@
+LDFLAGS = @LDFLAGS@
Index: configure.ac
===================================================================
RCS file: /cvsroot/htoolkit/HSQL/configure.ac,v
retrieving revision 1.5
diff -u -u -r1.5 configure.ac
--- configure.ac	7 Sep 2003 09:09:47 -0000	1.5
+++ configure.ac	4 Jan 2004 03:14:13 -0000
@@ -96,6 +96,56 @@
 AC_SUBST(GHC_PKG)
 
 dnl ***********************************************
+dnl Enable/Disable Hugs libraries
+dnl ***********************************************
+AC_ARG_ENABLE(hugs,
+[  --enable-hugs
+        Build Hugs libraries.
+],
+[WithHUGS=YES],
+[WithHUGS=NO]
+)
+AC_SUBST(WithHUGS)
+
+dnl ***********************************************
+dnl Hugs directory
+dnl ***********************************************
+AC_ARG_WITH(hugs-dir,
+[  --with-hugs-dir=<hugs directory>
+        Install Hugs libraries in the given Hugs directory (default is /usr/lib/hugs)
+],
+[HUGS_DIR="$withval"],
+[HUGS_DIR="/usr/lib/hugs"]
+)
+
+if test "$WithHUGS" = "YES"; then
+	if test "$HUGS_DIR" = "" || test ! -d $HUGS_DIR; then
+	   AC_MSG_ERROR([HUGS_DIR $HUGS_DIR does not exist])
+	fi
+fi
+
+AC_SUBST(HUGS_DIR)
+
+dnl ***********************************************
+dnl FFIHUGS
+dnl ***********************************************
+AC_ARG_WITH(ffihugs,
+[  --with-ffihugs=<ffihugs command>
+        Use a different command instead of 'ffihugs' for the Hugs FFI compiler.
+],
+[FFIHUGS="$withval"],
+[AC_PATH_PROG(FFIHUGS,ffihugs)]
+)
+
+if test "$WithHUGS" = "YES"; then
+	if test "$FFIHUGS" = "" || test ! -f $FFIHUGS; then
+	   AC_MSG_ERROR([ffihugs is required to build the Hugs libraries])
+	fi
+fi
+
+AC_SUBST(FFIHUGS)
+
+dnl ***********************************************
 dnl HADDOCK
 dnl ***********************************************
 AC_ARG_WITH(haddock,
@@ -228,6 +278,7 @@
 done
 
 AC_SUBST(CPPFLAGS)
+AC_SUBST(LDFLAGS,$LL)
 AC_SUBST(DEP_LIBS)
 AC_SUBST(LIB_DIRS)
 AC_SUBST(prefix)
Index: MySQL/HSQL.hsc
===================================================================
RCS file: /cvsroot/htoolkit/HSQL/MySQL/HSQL.hsc,v
retrieving revision 1.10
diff -u -u -r1.10 HSQL.hsc
--- MySQL/HSQL.hsc	27 Sep 2003 09:49:19 -0000	1.10
+++ MySQL/HSQL.hsc	4 Jan 2004 03:14:14 -0000
@@ -107,7 +107,13 @@
    | SqlFetchNull
 		{ seFieldName :: String
 		}
-   deriving (Typeable, Show)
+   deriving (Show)
+
+sqlErrorTc :: TyCon
+sqlErrorTc = mkTyCon "Database.MySQL.HSQL.SqlError"
+
+instance Typeable SqlError where
+	typeOf _ = mkAppTy sqlErrorTc []
 
 -----------------------------------------------------------------------------------------
 -- routines for handling exceptions
Index: ODBC/HSQL.hsc
===================================================================
RCS file: /cvsroot/htoolkit/HSQL/ODBC/HSQL.hsc,v
retrieving revision 1.8
diff -u -u -r1.8 HSQL.hsc
--- ODBC/HSQL.hsc	27 Sep 2003 09:49:19 -0000	1.8
+++ ODBC/HSQL.hsc	4 Jan 2004 03:14:14 -0000
@@ -31,6 +31,9 @@
 		, forEachRow        -- :: (Statement -> s -> IO s) -> Statement -> s -> IO s
 		, forEachRow'       -- :: (Statement -> IO ()) -> Statement -> IO ()
 		, collectRows       -- :: (Statement -> IO s) -> Statement -> IO [s]
+
+		, tables            -- :: Connection -> IO [String]
+		, describe          -- :: Connection -> String -> IO [(String, SqlType, Bool)]
 		) where
 
 import Data.Word(Word32, Word16)
@@ -39,7 +42,6 @@
 import Data.Dynamic
 import Foreign
 import Foreign.C
-import qualified Foreign.Concurrent as C
 import Control.Monad(when,unless)
 import Control.Exception (throwDyn, catchDyn, dynExceptions, Exception(..), finally)
 import System.IO.Unsafe
@@ -62,23 +64,23 @@
 type SQLLEN       = SQLINTEGER
 type SQLULEN      = SQLINTEGER
 
-foreign import stdcall "sqlext.h SQLAllocEnv" sqlAllocEnv :: Ptr HENV -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLFreeEnv" sqlFreeEnv :: HENV -> IO ()
-foreign import stdcall "sqlext.h SQLAllocConnect" sqlAllocConnect :: HENV -> Ptr HDBC -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLFreeConnect" sqlFreeConnect:: HDBC -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLConnect" sqlConnect :: HDBC -> CString -> Int -> CString -> Int -> CString -> Int -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLDisconnect" sqlDisconnect :: HDBC -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLAllocStmt" sqlAllocStmt :: HDBC -> Ptr HSTMT -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLFreeStmt" sqlFreeStmt :: HSTMT -> SQLUSMALLINT -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLNumResultCols" sqlNumResultCols :: HSTMT -> Ptr SQLUSMALLINT -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLDescribeCol" sqlDescribeCol :: HSTMT -> SQLUSMALLINT -> CString -> SQLSMALLINT -> Ptr SQLSMALLINT -> Ptr SQLSMALLINT -> Ptr SQLULEN -> Ptr SQLSMALLINT -> Ptr SQLSMALLINT -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLBindCol" sqlBindCol :: HSTMT -> SQLUSMALLINT -> SQLSMALLINT -> Ptr a -> SQLLEN -> Ptr SQLINTEGER -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLFetch" sqlFetch :: HSTMT -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLGetDiagRec" sqlGetDiagRec :: SQLSMALLINT -> SQLHANDLE -> SQLSMALLINT -> CString -> Ptr SQLINTEGER -> CString -> SQLSMALLINT -> Ptr SQLSMALLINT -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLExecDirect" sqlExecDirect :: HSTMT -> CString -> Int -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLSetConnectOption" sqlSetConnectOption :: HDBC -> SQLUSMALLINT -> SQLULEN -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLTransact" sqlTransact :: HENV -> HDBC -> SQLUSMALLINT -> IO SQLRETURN
-foreign import stdcall "sqlext.h SQLGetData" sqlGetData :: HSTMT -> SQLUSMALLINT -> SQLSMALLINT -> Ptr () -> SQLINTEGER -> Ptr SQLINTEGER -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLAllocEnv" sqlAllocEnv :: Ptr HENV -> IO SQLRETURN
+foreign import ccall "sqlext.h &SQLFreeEnv" sqlFreeEnv_p :: FunPtr (HENV -> IO ())
+foreign import ccall "sqlext.h SQLAllocConnect" sqlAllocConnect :: HENV -> Ptr HDBC -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLFreeConnect" sqlFreeConnect:: HDBC -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLConnect" sqlConnect :: HDBC -> CString -> Int -> CString -> Int -> CString -> Int -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLDisconnect" sqlDisconnect :: HDBC -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLAllocStmt" sqlAllocStmt :: HDBC -> Ptr HSTMT -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLFreeStmt" sqlFreeStmt :: HSTMT -> SQLUSMALLINT -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLNumResultCols" sqlNumResultCols :: HSTMT -> Ptr SQLUSMALLINT -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLDescribeCol" sqlDescribeCol :: HSTMT -> SQLUSMALLINT -> CString -> SQLSMALLINT -> Ptr SQLSMALLINT -> Ptr SQLSMALLINT -> Ptr SQLULEN -> Ptr SQLSMALLINT -> Ptr SQLSMALLINT -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLBindCol" sqlBindCol :: HSTMT -> SQLUSMALLINT -> SQLSMALLINT -> Ptr a -> SQLLEN -> Ptr SQLINTEGER -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLFetch" sqlFetch :: HSTMT -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLGetDiagRec" sqlGetDiagRec :: SQLSMALLINT -> SQLHANDLE -> SQLSMALLINT -> CString -> Ptr SQLINTEGER -> CString -> SQLSMALLINT -> Ptr SQLSMALLINT -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLExecDirect" sqlExecDirect :: HSTMT -> CString -> Int -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLSetConnectOption" sqlSetConnectOption :: HDBC -> SQLUSMALLINT -> SQLULEN -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLTransact" sqlTransact :: HENV -> HDBC -> SQLUSMALLINT -> IO SQLRETURN
+foreign import ccall "sqlext.h SQLGetData" sqlGetData :: HSTMT -> SQLUSMALLINT -> SQLSMALLINT -> Ptr () -> SQLINTEGER -> Ptr SQLINTEGER -> IO SQLRETURN
 
 
 -- | A 'Connection' type represents a connection to a data source, through which you can operate on the data source. 
@@ -138,7 +140,13 @@
    | SqlFetchNull
    		{ seFieldName :: String
 		}
-   deriving (Show, Typeable)
+   deriving (Show)
+
+sqlErrorTc :: TyCon
+sqlErrorTc = mkTyCon "Database.ODBC.HSQL.SqlError"
+
+instance Typeable SqlError where
+	typeOf _ = mkAppTy sqlErrorTc []
    
 -----------------------------------------------------------------------------------------
 -- routines for handling exceptions
@@ -191,7 +199,7 @@
 	hEnv <- peek phEnv
 	free phEnv
 	handleSqlResult 0 nullPtr res
-	C.newForeignPtr hEnv (sqlFreeEnv hEnv)
+	newForeignPtr sqlFreeEnv_p hEnv
 
 -----------------------------------------------------------------------------------------
 -- Connect/Disconnect
@@ -247,9 +255,9 @@
 	sqlFreeStmt hSTMT 0 >>= handleSqlResult (#const SQL_HANDLE_STMT) hSTMT
 	free pFIELD
 
--- | Executes the statement and returns a 'Statement' value which represents the result set
-query :: Connection -> String -> IO Statement
-query conn@(Connection {hDBC=hDBC}) query = do
+-- ^ Allocates a statement and calls the given function on it.
+withStatement :: Connection -> (HSTMT -> IO SQLRETURN) -> IO Statement
+withStatement conn@(Connection {hDBC=hDBC}) f = do
 	pFIELD <- mallocBytes (#const sizeof(FIELD))	
 	res <- sqlAllocStmt hDBC ((#ptr FIELD, hSTMT) pFIELD)
 	unless (sqlSuccess res) (free pFIELD)
@@ -258,10 +266,7 @@
 	let handleResult res = do
 		unless (sqlSuccess res) (free pFIELD)
 		handleSqlResult (#const SQL_HANDLE_STMT) hSTMT res
-	pQuery <- newCString query
-	res <- sqlExecDirect hSTMT pQuery (length query)
-	free pQuery
-	handleResult res
+	res <- f hSTMT
 	sqlNumResultCols hSTMT ((#ptr FIELD, fieldsCount) pFIELD) >>= handleResult
 	count <- (#peek FIELD, fieldsCount) pFIELD
 	(fields, bufSize) <- getFieldDefs hSTMT pFIELD 1 count
@@ -286,25 +291,32 @@
 				(fields, fullBufSize) <- getFieldDefs hSTMT pFIELD (n+1) count
 				return ((name,sqlType,toBool nullable):fields, max bufSize fullBufSize)
 				
-		mkSqlType :: SQLSMALLINT -> SQLULEN -> SQLSMALLINT -> (SqlType, SQLINTEGER)
-		mkSqlType (#const SQL_CHAR)         size    _    = (SqlChar (fromIntegral size), (#const sizeof(SQLCHAR))*(fromIntegral size+1))
-		mkSqlType (#const SQL_VARCHAR)      size    _    = (SqlVarChar (fromIntegral size), (#const sizeof(SQLCHAR))*(fromIntegral size+1))
-		mkSqlType (#const SQL_LONGVARCHAR)  size    _    = (SqlLongVarChar (fromIntegral size), 1) -- dummy bufSize
-		mkSqlType (#const SQL_DECIMAL)      size    prec = (SqlDecimal (fromIntegral size) (fromIntegral prec), (#const sizeof(SQLDOUBLE)))
-		mkSqlType (#const SQL_NUMERIC)      size    prec = (SqlNumeric (fromIntegral size) (fromIntegral prec), (#const sizeof(SQLDOUBLE)))
-		mkSqlType (#const SQL_SMALLINT)     _       _    = (SqlSmallInt, (#const sizeof(SQLSMALLINT)))
-		mkSqlType (#const SQL_INTEGER)      _       _    = (SqlInteger, (#const sizeof(SQLINTEGER)))
-		mkSqlType (#const SQL_REAL)         _       _    = (SqlReal, (#const sizeof(SQLDOUBLE)))
-		mkSqlType (#const SQL_DOUBLE)		_    	_    = (SqlDouble, (#const sizeof(SQLDOUBLE)))
-		mkSqlType (#const SQL_BIT)          _    	_    = (SqlBit, (#const sizeof(SQLINTEGER)))
-		mkSqlType (#const SQL_TINYINT)      _    	_    = (SqlTinyInt, (#const sizeof(SQLSMALLINT)))
-		mkSqlType (#const SQL_BIGINT)       _    	_    = (SqlBigInt, (#const sizeof(SQLINTEGER)))
-		mkSqlType (#const SQL_BINARY)       size    _    = (SqlBinary (fromIntegral size), (#const sizeof(SQLCHAR))*(fromIntegral size+1))
-		mkSqlType (#const SQL_VARBINARY)    size    _    = (SqlVarBinary (fromIntegral size), (#const sizeof(SQLCHAR))*(fromIntegral size+1))
-		mkSqlType (#const SQL_LONGVARBINARY)size    _    = (SqlLongVarBinary (fromIntegral size), 1) -- dummy bufSize
-		mkSqlType (#const SQL_DATE)         _    	_    = (SqlDate, (#const sizeof(SQL_DATE_STRUCT)))
-		mkSqlType (#const SQL_TIME)         _    	_    = (SqlTime, (#const sizeof(SQL_TIME_STRUCT)))
-		mkSqlType (#const SQL_TIMESTAMP)	_    	_    = (SqlTimeStamp, (#const sizeof(SQL_TIMESTAMP_STRUCT)))
+
+-- | Executes the statement and returns a 'Statement' value which represents the result set
+query :: Connection -> String -> IO Statement
+query conn q = withStatement conn doQuery
+    where doQuery hSTMT = withCStringLen q (uncurry (sqlExecDirect hSTMT))
+
+				
+mkSqlType :: SQLSMALLINT -> SQLULEN -> SQLSMALLINT -> (SqlType, SQLINTEGER)
+mkSqlType (#const SQL_CHAR)         size    _    = (SqlChar (fromIntegral size), (#const sizeof(SQLCHAR))*(fromIntegral size+1))
+mkSqlType (#const SQL_VARCHAR)      size    _    = (SqlVarChar (fromIntegral size), (#const sizeof(SQLCHAR))*(fromIntegral size+1))
+mkSqlType (#const SQL_LONGVARCHAR)  size    _    = (SqlLongVarChar (fromIntegral size), 1) -- dummy bufSize
+mkSqlType (#const SQL_DECIMAL)      size    prec = (SqlDecimal (fromIntegral size) (fromIntegral prec), (#const sizeof(SQLDOUBLE)))
+mkSqlType (#const SQL_NUMERIC)      size    prec = (SqlNumeric (fromIntegral size) (fromIntegral prec), (#const sizeof(SQLDOUBLE)))
+mkSqlType (#const SQL_SMALLINT)     _       _    = (SqlSmallInt, (#const sizeof(SQLSMALLINT)))
+mkSqlType (#const SQL_INTEGER)      _       _    = (SqlInteger, (#const sizeof(SQLINTEGER)))
+mkSqlType (#const SQL_REAL)         _       _    = (SqlReal, (#const sizeof(SQLDOUBLE)))
+mkSqlType (#const SQL_DOUBLE)		_    	_    = (SqlDouble, (#const sizeof(SQLDOUBLE)))
+mkSqlType (#const SQL_BIT)          _    	_    = (SqlBit, (#const sizeof(SQLINTEGER)))
+mkSqlType (#const SQL_TINYINT)      _    	_    = (SqlTinyInt, (#const sizeof(SQLSMALLINT)))
+mkSqlType (#const SQL_BIGINT)       _    	_    = (SqlBigInt, (#const sizeof(SQLINTEGER)))
+mkSqlType (#const SQL_BINARY)       size    _    = (SqlBinary (fromIntegral size), (#const sizeof(SQLCHAR))*(fromIntegral size+1))
+mkSqlType (#const SQL_VARBINARY)    size    _    = (SqlVarBinary (fromIntegral size), (#const sizeof(SQLCHAR))*(fromIntegral size+1))
+mkSqlType (#const SQL_LONGVARBINARY)size    _    = (SqlLongVarBinary (fromIntegral size), 1) -- dummy bufSize
+mkSqlType (#const SQL_DATE)         _    	_    = (SqlDate, (#const sizeof(SQL_DATE_STRUCT)))
+mkSqlType (#const SQL_TIME)         _    	_    = (SqlTime, (#const sizeof(SQL_TIME_STRUCT)))
+mkSqlType (#const SQL_TIMESTAMP)	_    	_    = (SqlTimeStamp, (#const sizeof(SQL_TIMESTAMP_STRUCT)))
 
 
 {-# NOINLINE fetch #-}
@@ -568,3 +580,57 @@
 					xs <- loop
 					return (x:xs)
 				else return []
+
+-----------------------------------------------------------------------------------------
+-- getting table and column info
+-----------------------------------------------------------------------------------------
+
+foreign import ccall "sqlext.h SQLTables" sqlTables 
+    :: HSTMT -> CString -> SQLSMALLINT -> CString -> SQLSMALLINT 
+    -> CString -> SQLSMALLINT -> CString -> SQLSMALLINT 
+    -> IO SQLRETURN
+
+foreign import ccall "sqlext.h SQLColumns" sqlColumns
+    :: HSTMT -> CString -> SQLSMALLINT -> CString -> SQLSMALLINT 
+    -> CString -> SQLSMALLINT -> CString -> SQLSMALLINT 
+    -> IO SQLRETURN
+
+-- | List all tables in the database.
+tables :: Connection -- ^ Database connection
+	  -> IO [String] -- ^ The names of all tables in the database.
+tables conn = do  
+      stmt <- withStatement conn sqlTable'
+      -- SQLTable returns:
+      -- Column name     #   Type
+      -- TABLE_NAME      3   VARCHAR
+      collectRows (\s -> getFieldValue' s "TABLE_NAME" "") stmt
+      where sqlTable' hSTMT = sqlTables hSTMT nullPtr 0 nullPtr 0 nullPtr 0 nullPtr 0
+
+-- | List all columns in a table along with their types and @nullable@ flags
+describe :: Connection -- ^ Database connection
+	   -> String -- ^ Name of a database table
+	   -> IO [(String, SqlType, Bool)] -- ^ @[(name, type, nullable)]@
+describe conn table = do
+      stmt <- withStatement conn (\hSTMT -> sqlColumns' hSTMT table)
+      collectRows getColumnInfo stmt
+      where
+      sqlColumns' hSTMT table = 
+	  withCStringLen table (\(pTable,len) -> 
+	      sqlColumns hSTMT nullPtr 0 nullPtr 0 pTable (fromIntegral len) nullPtr 0)
+      -- SQLColumns returns:
+      -- Column name     #   Type
+      -- COLUMN_NAME     4   Varchar not NULL
+      -- DATA_TYPE       5   Smallint not NULL
+      -- COLUMN_SIZE     7   Integer
+      -- DECIMAL_DIGITS  9   Smallint
+      -- NULLABLE       11   Smallint not NULL
+      getColumnInfo stmt = 
+	  do
+	  name <- getFieldValue stmt "COLUMN_NAME"
+	  (t::Int) <- getFieldValue stmt "DATA_TYPE"
+	  (size::Int) <- getFieldValue' stmt "COLUMN_SIZE" 0
+	  (prec::Int) <- getFieldValue' stmt "DECIMAL_DIGITS" 0
+	  (n::Int) <- getFieldValue stmt "NULLABLE"
+	  let (sqlType,_) = mkSqlType (fromIntegral t) (fromIntegral size) (fromIntegral prec)
+	      nullable = n /= (#const SQL_NO_NULLS)
+	  return (name, sqlType, nullable)
Index: PostgreSQL/HSQL.hsc
===================================================================
RCS file: /cvsroot/htoolkit/HSQL/PostgreSQL/HSQL.hsc,v
retrieving revision 1.10
diff -u -u -r1.10 HSQL.hsc
--- PostgreSQL/HSQL.hsc	27 Sep 2003 09:49:19 -0000	1.10
+++ PostgreSQL/HSQL.hsc	4 Jan 2004 03:14:14 -0000
@@ -140,7 +140,14 @@
    | SqlFetchNull
 		{ seFieldName :: String
 		}
-   deriving (Show, Typeable)
+   deriving (Show)
+
+sqlErrorTc :: TyCon
+sqlErrorTc = mkTyCon "Database.PostgreSQL.HSQL.SqlError"
+
+instance Typeable SqlError where
+	typeOf _ = mkAppTy sqlErrorTc []
+
 
 -----------------------------------------------------------------------------------------
 -- routines for handling exceptions
