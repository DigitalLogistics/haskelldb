-----------------------------------------------------------
-- |
-- Module      :  DBSpecToDBDirect
-- Copyright   :  HWT Group (c) 2004, dp03-7@mdstud.chalmers.se
-- License     :  BSD-style
-- 
-- Maintainer  :  dp03-7@mdstud.chalmers.se
-- Stability   :  experimental
-- Portability :  portable
--
-- Converts a DBSpec-generated database to a set of
-- (FilePath,Doc), that can be used to generate definition 
-- files usable in HaskellDB (the generation itself is done 
-- in DBDirect)
-----------------------------------------------------------
module DBSpecToDBDirect
    (specToHDB) 
    where
import Database.HaskellDB.BoundedString
import Database.HaskellDB.FieldType

import Database.HaskellDB
import Database.HaskellDB.PrimQuery
import Database.HaskellDB.DBSpec

import Database.HaskellDB.DBSpec.PPHelpers
--import DbDirectCommon

import Text.PrettyPrint.HughesPJ

-- | Common header for all files
header = ppComment ["Generated by DB/Direct"]

-- | Imports all generated files have
imports = vcat (map (text . ("import " ++)) 
		["Database.HaskellDB.HDBRec",
		 "Database.HaskellDB.HDBRecUtils",
		 "Database.HaskellDB.BoundedString",
		 "System.Time (CalendarTime)",
		 "Database.HaskellDB.Query (Expr, Table, Attr, baseTable)"])

-- | Converts a database specification to a "finished" set of files
specToHDB :: DBInfo -> [(FilePath,Doc)]
specToHDB dbinfo = genDocs (constructNonClashingDBInfo dbinfo)

-- | Does the actual conversion work
genDocs :: DBInfo -> [(FilePath,Doc)]
genDocs dbinfo 
    = ("./" ++ ((moduleName . dbname) dbinfo) ++ ".hs",
       header
       $$ text "module" <+> text ((moduleName . dbname) dbinfo) 
       <+> text "where"
       <> newline
       $$ vcat (map (text . (("import qualified " ++ 
			      ((moduleName . dbname) dbinfo) ++ ".") ++)) 
		tbnames))
        : map (tInfoToModule ((moduleName . dbname) dbinfo)) (tbls dbinfo)
    where
    tbnames = map (moduleName . tname) (tbls dbinfo)
      
-- | Makes a module from a TInfo
tInfoToModule :: String -- ^ The name of our main module
	      -> TInfo -> (FilePath,Doc)
tInfoToModule dbname tinfo@TInfo{tname=name,cols=col}
    = ("./" ++ dbname ++ "/" ++ (moduleName name) ++ ".hs",
       header
       $$ text "module" <+> 
       text ((moduleName dbname) ++ "." ++ (moduleName name)) <+> 
       text "where"
       <> newline
       $$ imports
       <> newline
       $$ ppComment ["Table"]
       $$ ppTInfo tinfo       
       $$ ppComment ["Fields"]
       $$ vcat (map ppField (columnNamesTypes tinfo)))

-- | Pretty prints a TableInfo
ppTInfo :: TInfo -> Doc
ppTInfo (TInfo tiName tiColumns) =  
    hang (text (identifier tiName) <+> text "::" <+> text "Table") 4 
	 (parens (ppColumns tiColumns)
	 <>  newline)
    $$  
    text (identifier tiName) <+> text "=" <+> 
    hang (text "baseTable" <+> 
	  doubleQuotes (text (checkChars $ checkLower tiName)) <+> 
	  text "$") 0
	     (vcat $ punctuate (text " #") (map ppColumnValue tiColumns))
	     <>  newline

-- | Pretty prints a list of ColumnInfo
ppColumns []      = text ""
ppColumns [c]     = parens (ppColumnType c <+> text "HDBRecTail")
ppColumns (c:cs)  = parens (ppColumnType c $$ ppColumns cs)

-- | Pretty prints the type field in a ColumnInfo	
ppColumnType :: CInfo -> Doc 
ppColumnType (CInfo ciName (ciType,ciAllowNull))
	=   text "HDBRecCons" <+> 
	    ((text $ toType ciName) <+> parens (text "Expr"
	    <+> (if (ciAllowNull)
	      then parens (text "Maybe" <+> text (show ciType))
	      else text (show ciType)
	    )))

-- | Pretty prints the value field in a ColumnInfo
ppColumnValue :: CInfo -> Doc 
ppColumnValue (CInfo ciName _)
	=   text "hdbMakeEntry" <+> text (toType ciName)

-- | Pretty prints Field definitions
ppField :: (String,String) -> Doc
ppField (name,typeof) = 
    ppComment [toType name ++ " Field"]
    <> newline $$
    text "data" <+> bname <+> equals <+> bname -- <+> text "deriving Show"
    <> newline $$
    hang (text "instance FieldTag" <+> bname <+> text "where") 4 
         (text "fieldName _" <+> equals <+> doubleQuotes 
	         (text (checkChars $ checkLower name)))
    <> newline $$
    
    iname <+> text "::" <+> text "Attr" <+> bname <+> text typeof
    $$ 
    iname <+> equals <+> text "mkAttr" <+> bname
    <> newline
	where
	bname = text (toType name)
	iname = text (identifier name)

-- | Extracts all the column names from a TableInfo
columnNames :: TInfo -> [String]
columnNames table = map cname (cols table)

-- | Extracts all the column types from a TableInfo
columnTypes :: TInfo -> [String]
columnTypes table = 
    [if b then ("(Maybe " ++ t ++ ")") else t | (t,b) <- zippedlist]
    where
    zippedlist = zip typelist null_list
    typelist  = map (show . fst . descr) (cols table)
    null_list = map (snd . descr) (cols table)

-- | Combines the results of columnNames and columnTypes
columnNamesTypes :: TInfo -> [(String,String)]
columnNamesTypes table@(TInfo tname fields) 
    = zip (columnNames table) (columnTypes table)